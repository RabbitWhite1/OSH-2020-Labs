# Lab3

PB18111697 王章瀚

## 需注意的地方

1. Makefile文件中, 可以用make生成三个代码(`1.c`, `2.c`, `3.c`)对应的可执行文件(`1`, `2`, `3`). 这里沿袭助教的做法, 通过命令行参数提供端口.
2. 由于程序`2.c`的范围完全覆盖了程序`1.c`的, 故`1.c`除了实验要求的按`\n`分割消息以及处理`send`外, 并无做其他完善(如中途加入退出等).

## 实现的简要描述

### 按`\n`分割消息

这里采用的方法是: 每次接收一定量的字符串后, 由STL的`find`查找`'\n'`, 然后放入MessageManager来处理成一条一条的消息, 并加上标头(发送方等信息).
每次需要发送的时候就从`tosend`里取出即可.

### 处理可能的阻塞

这里直接判断发送了的数量, 然后截去对应部分, 继续发送剩余部分.

而这里为了避免发送中, 客户端退出等各种因素的影响, 还对客户端的退出进行了判断, 采用的是带`MSG_PEEK`的recv, 并且结合`errno`做一些其他判断.

### 多线程实现部分

大体框架是: 在`main`函数中有一个循环, 用以不断接受`accept`客户端的连接. 每当有客户端连接, 就new一个`Client`对象, 这个对象将开始执行两个线程: 一是接收, 而是发送. 然后两个线程并行执行, 从而完成了多线程的收发. 而为了防止接收某个客户端的信息只接收了一半就被其他客户端的新信息截断, 这里要求收到完整的信息后(存于`reader`), 才将整条信息转存到其他客户端的`tosend`.

### 异步IO实现部分

大体框架是: 用一个循环不断接受客户端, 接收和转发客户端的消息. 转发的时候将对客户端的可接收消息, 可发送消息, 连接正常与否等进行一系列判断, 从而保证了整个程序的正常运行.
