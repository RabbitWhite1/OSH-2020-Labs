# Lab3

PB18111697 王章瀚

## 需注意的地方

1. Makefile文件中, 可以用make生成三个代码(`1.c`, `2.c`, `3.c`)对应的可执行文件(`1`, `2`, `3`). 这里沿袭助教的做法, 通过命令行参数提供端口.
2. 由于程序`2.c`的范围完全覆盖了程序`1.c`的, 故`1.c`除了实验要求的按`\n`分割消息以及处理`send`外, 并无做其他完善(如中途加入退出等).

## 实现的简要描述

### 按`\n`分割消息

这里采用的方法是: 每次接收一定量的字符串后, 通过`strchr`查找字符串中的换行符`\n`. 如果存在`\n`, 则先发送其之前的部分, 然后重新发送一个`Message提示符`之类的提示, 再继续发送剩余部分. 这样就实现了分割.

这里值得注意的是, 需要有一个标识来记录本次转发是否完成(即转发内容是否达到了`\n`). 这样才能够决定发送前是否需要先接一个`Message提示符`.

### 处理可能的阻塞

此处采用的是循环发送直到发送正常. 当且仅当成功发送信息量(send的返回值)和需要发送的一样时, 才判断为发送成功, 否则继续循环以发送. 

而这里为了避免发送循环中, 客户端退出等各种因素的影响, 还对客户端的退出进行了判断, 采用的是带`MSG_PEEK`的recv, 并且结合`errno`做一些其他判断.

### 多线程实现部分

大体框架是: 在`main`函数中有一个循环, 用以不断接受`accept`客户端的连接. 每当有客户端连接, 就为它开辟一个新线程, 这个线程用以接受客户端发送的消息, 并用`for`循环(而非多线程)的方式转发消息. 这里转发的时候将上`send_mutex`锁, 以避免不同的客户端线程同时进行转发, 从而引发混乱.

### 异步IO实现部分

大体框架是: 用一个循环不断接受客户端, 接收和转发客户端的消息. 转发的时候将对客户端的可接收消息, 可发送消息, 连接正常与否等进行一系列判断, 从而保证了整个程序的正常运行.
